/* Generated By:JJTree: Do not edit this line. SQLTraverseStatement.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=true,NODE_PREFIX=O,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.jetbrains.youtrack.db.internal.core.sql.parser;

import com.jetbrains.youtrack.db.internal.core.command.BasicCommandContext;
import com.jetbrains.youtrack.db.internal.core.command.CommandContext;
import com.jetbrains.youtrack.db.internal.core.db.YTDatabaseSessionInternal;
import com.jetbrains.youtrack.db.internal.core.sql.YTCommandSQLParsingException;
import com.jetbrains.youtrack.db.internal.core.sql.executor.OInternalExecutionPlan;
import com.jetbrains.youtrack.db.internal.core.sql.executor.OTraverseExecutionPlanner;
import com.jetbrains.youtrack.db.internal.core.sql.executor.YTResultSet;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;

public class SQLTraverseStatement extends SQLStatement {

  public enum Strategy {
    DEPTH_FIRST,
    BREADTH_FIRST
  }

  protected List<SQLTraverseProjectionItem> projections = new ArrayList<SQLTraverseProjectionItem>();

  protected SQLFromClause target;

  protected SQLWhereClause whileClause;

  protected SQLSkip skip;

  protected SQLLimit limit;

  protected Strategy strategy;

  protected SQLInteger maxDepth;

  public SQLTraverseStatement(int id) {
    super(id);
  }

  public SQLTraverseStatement(YouTrackDBSql p, int id) {
    super(p, id);
  }

  public void validate() throws YTCommandSQLParsingException {
    //    for(SQLTraverseProjectionItem projection:projections) {
    //
    //        projection. validate();
    //        if (projection.isExpand() && groupBy != null) {
    //          throw new YTCommandSQLParsingException("expand() cannot be used together with GROUP
    // BY");
    //        }
    //
    //    }
    if (target.getItem().getStatement() != null) {
      target.getItem().getStatement().validate();
    }
  }

  @Override
  public YTResultSet execute(
      YTDatabaseSessionInternal db, Object[] args, CommandContext parentCtx,
      boolean usePlanCache) {
    BasicCommandContext ctx = new BasicCommandContext();
    if (parentCtx != null) {
      ctx.setParentWithoutOverridingChild(parentCtx);
    }
    ctx.setDatabase(db);
    Map<Object, Object> params = new HashMap<>();
    if (args != null) {
      for (int i = 0; i < args.length; i++) {
        params.put(i, args[i]);
      }
    }
    ctx.setInputParameters(params);
    OInternalExecutionPlan executionPlan;
    if (usePlanCache) {
      executionPlan = createExecutionPlan(ctx, false);
    } else {
      executionPlan = createExecutionPlanNoCache(ctx, false);
    }

    return new YTLocalResultSet(executionPlan);
  }

  @Override
  public YTResultSet execute(
      YTDatabaseSessionInternal db, Map params, CommandContext parentCtx, boolean usePlanCache) {
    BasicCommandContext ctx = new BasicCommandContext();
    if (parentCtx != null) {
      ctx.setParentWithoutOverridingChild(parentCtx);
    }
    ctx.setDatabase(db);
    ctx.setInputParameters(params);
    OInternalExecutionPlan executionPlan;
    if (usePlanCache) {
      executionPlan = createExecutionPlan(ctx, false);
    } else {
      executionPlan = createExecutionPlanNoCache(ctx, false);
    }

    return new YTLocalResultSet(executionPlan);
  }

  public OInternalExecutionPlan createExecutionPlan(CommandContext ctx, boolean enableProfiling) {
    OTraverseExecutionPlanner planner = new OTraverseExecutionPlanner(this);
    OInternalExecutionPlan result = planner.createExecutionPlan(ctx, enableProfiling);
    result.setStatement(originalStatement);
    result.setGenericStatement(this.toGenericStatement());
    return result;
  }

  public void toString(Map<Object, Object> params, StringBuilder builder) {
    builder.append("TRAVERSE ");
    boolean first = true;
    for (SQLTraverseProjectionItem item : projections) {
      if (!first) {
        builder.append(", ");
      }
      item.toString(params, builder);
      first = false;
    }

    if (target != null) {
      builder.append(" FROM ");
      target.toString(params, builder);
    }

    if (maxDepth != null) {
      builder.append(" MAXDEPTH ");
      maxDepth.toString(params, builder);
    }

    if (whileClause != null) {
      builder.append(" WHILE ");
      whileClause.toString(params, builder);
    }

    if (limit != null) {
      builder.append(" ");
      limit.toString(params, builder);
    }

    if (strategy != null) {
      builder.append(" strategy ");
      switch (strategy) {
        case BREADTH_FIRST:
          builder.append("breadth_first");
          break;
        case DEPTH_FIRST:
          builder.append("depth_first");
          break;
      }
    }
  }

  public void toGenericStatement(StringBuilder builder) {
    builder.append("TRAVERSE ");
    boolean first = true;
    for (SQLTraverseProjectionItem item : projections) {
      if (!first) {
        builder.append(", ");
      }
      item.toGenericStatement(builder);
      first = false;
    }

    if (target != null) {
      builder.append(" FROM ");
      target.toGenericStatement(builder);
    }

    if (maxDepth != null) {
      builder.append(" MAXDEPTH ");
      maxDepth.toGenericStatement(builder);
    }

    if (whileClause != null) {
      builder.append(" WHILE ");
      whileClause.toGenericStatement(builder);
    }

    if (limit != null) {
      builder.append(" ");
      limit.toGenericStatement(builder);
    }

    if (strategy != null) {
      builder.append(" strategy ");
      switch (strategy) {
        case BREADTH_FIRST:
          builder.append("breadth_first");
          break;
        case DEPTH_FIRST:
          builder.append("depth_first");
          break;
      }
    }
  }

  public boolean refersToParent() {
    if (projections != null && projections.stream().anyMatch(x -> x.refersToParent())) {
      return true;
    }
    if (this.target != null && this.target.refersToParent()) {
      return true;
    }
    return this.whileClause != null && this.whileClause.refersToParent();
  }

  @Override
  public SQLStatement copy() {
    SQLTraverseStatement result = new SQLTraverseStatement(-1);
    result.projections =
        projections == null
            ? null
            : projections.stream().map(x -> x.copy()).collect(Collectors.toList());
    result.target = target == null ? null : target.copy();
    result.whileClause = whileClause == null ? null : whileClause.copy();
    result.limit = limit == null ? null : limit.copy();
    result.strategy = strategy;
    result.maxDepth = maxDepth == null ? null : maxDepth.copy();
    return result;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }

    SQLTraverseStatement that = (SQLTraverseStatement) o;

    if (!Objects.equals(projections, that.projections)) {
      return false;
    }
    if (!Objects.equals(target, that.target)) {
      return false;
    }
    if (!Objects.equals(whileClause, that.whileClause)) {
      return false;
    }
    if (!Objects.equals(limit, that.limit)) {
      return false;
    }
    if (strategy != that.strategy) {
      return false;
    }
    return Objects.equals(maxDepth, that.maxDepth);
  }

  @Override
  public int hashCode() {
    int result = projections != null ? projections.hashCode() : 0;
    result = 31 * result + (target != null ? target.hashCode() : 0);
    result = 31 * result + (whileClause != null ? whileClause.hashCode() : 0);
    result = 31 * result + (limit != null ? limit.hashCode() : 0);
    result = 31 * result + (strategy != null ? strategy.hashCode() : 0);
    result = 31 * result + (maxDepth != null ? maxDepth.hashCode() : 0);
    return result;
  }

  @Override
  public boolean isIdempotent() {
    return true;
  }

  public List<SQLTraverseProjectionItem> getProjections() {
    return projections;
  }

  public void setProjections(List<SQLTraverseProjectionItem> projections) {
    this.projections = projections;
  }

  public SQLFromClause getTarget() {
    return target;
  }

  public void setTarget(SQLFromClause target) {
    this.target = target;
  }

  public SQLWhereClause getWhileClause() {
    return whileClause;
  }

  public void setWhileClause(SQLWhereClause whileClause) {
    this.whileClause = whileClause;
  }

  public SQLLimit getLimit() {
    return limit;
  }

  public void setLimit(SQLLimit limit) {
    this.limit = limit;
  }

  public Strategy getStrategy() {
    return strategy;
  }

  public void setStrategy(Strategy strategy) {
    this.strategy = strategy;
  }

  public SQLInteger getMaxDepth() {
    return maxDepth;
  }

  public void setMaxDepth(SQLInteger maxDepth) {
    this.maxDepth = maxDepth;
  }

  public SQLSkip getSkip() {
    return skip;
  }

  public void setSkip(SQLSkip skip) {
    this.skip = skip;
  }

  public void addProjection(SQLTraverseProjectionItem item) {
    this.projections.add(item);
  }
}
/* JavaCC - OriginalChecksum=47399a3a3d5a423768bbdc70ee957464 (do not edit this line) */
