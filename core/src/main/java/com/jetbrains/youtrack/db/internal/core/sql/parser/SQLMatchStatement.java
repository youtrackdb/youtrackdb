/* Generated By:JJTree: Do not edit this line. SQLMatchStatement.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=true,NODE_PREFIX=O,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package com.jetbrains.youtrack.db.internal.core.sql.parser;

import com.jetbrains.youtrack.db.api.exception.CommandExecutionException;
import com.jetbrains.youtrack.db.api.exception.RecordNotFoundException;
import com.jetbrains.youtrack.db.api.query.ResultSet;
import com.jetbrains.youtrack.db.api.record.DBRecord;
import com.jetbrains.youtrack.db.api.record.Identifiable;
import com.jetbrains.youtrack.db.api.schema.PropertyType;
import com.jetbrains.youtrack.db.api.schema.Schema;
import com.jetbrains.youtrack.db.api.schema.SchemaClass;
import com.jetbrains.youtrack.db.internal.common.util.PairLongObject;
import com.jetbrains.youtrack.db.internal.core.command.BasicCommandContext;
import com.jetbrains.youtrack.db.internal.core.command.CommandContext;
import com.jetbrains.youtrack.db.internal.core.db.DatabaseSessionInternal;
import com.jetbrains.youtrack.db.internal.core.metadata.security.Role;
import com.jetbrains.youtrack.db.internal.core.metadata.security.Rule;
import com.jetbrains.youtrack.db.internal.core.record.impl.EntityImpl;
import com.jetbrains.youtrack.db.internal.core.record.impl.EntityInternalUtils;
import com.jetbrains.youtrack.db.internal.core.sql.CommandExecutorSQLResultsetDelegate;
import com.jetbrains.youtrack.db.internal.core.sql.CommandExecutorSQLSelect;
import com.jetbrains.youtrack.db.internal.core.sql.IterableRecordSource;
import com.jetbrains.youtrack.db.internal.core.sql.executor.InternalExecutionPlan;
import com.jetbrains.youtrack.db.internal.core.sql.executor.MatchExecutionPlanner;
import com.jetbrains.youtrack.db.internal.core.sql.executor.PatternEdge;
import com.jetbrains.youtrack.db.internal.core.sql.executor.PatternNode;
import com.jetbrains.youtrack.db.internal.core.sql.filter.SQLTarget;
import com.jetbrains.youtrack.db.internal.core.sql.query.SQLAsynchQuery;
import com.jetbrains.youtrack.db.internal.core.sql.query.SQLSynchQuery;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.IdentityHashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

public final class SQLMatchStatement extends SQLStatement implements IterableRecordSource {

  static final String DEFAULT_ALIAS_PREFIX = "$YOUTRACKDB_DEFAULT_ALIAS_";

  public static final String KEYWORD_MATCH = "MATCH";
  // parsed data
  private List<SQLMatchExpression> matchExpressions = new ArrayList<>();
  private List<SQLMatchExpression> notMatchExpressions = new ArrayList<>();
  private List<SQLExpression> returnItems = new ArrayList<>();
  private List<SQLIdentifier> returnAliases = new ArrayList<>();
  private List<SQLNestedProjection> returnNestedProjections = new ArrayList<>();
  boolean returnDistinct = false;
  SQLGroupBy groupBy;
  SQLOrderBy orderBy;
  SQLUnwind unwind;
  SQLSkip skip;
  SQLLimit limit;

  // post-parsing generated data
  Pattern pattern;

  private Map<String, SQLWhereClause> aliasFilters;

  // execution data
  private CommandContext context;

  long threshold = 20;
  private final int limitFromProtocol = -1;

  public List<SQLNestedProjection> getReturnNestedProjections() {
    return returnNestedProjections;
  }

  public void setContext(CommandContext context) {
    this.context = context;
  }

  public void setReturnNestedProjections(List<SQLNestedProjection> returnNestedProjections) {
    this.returnNestedProjections = returnNestedProjections;
  }

  public void addMatchExpression(SQLMatchExpression exp) {
    this.matchExpressions.add(exp);
  }

  public void addNotMatchExpression(SQLMatchExpression exp) {
    this.notMatchExpressions.add(exp);
  }

  public void addReturnNestedProjection(SQLNestedProjection projection) {
    this.returnNestedProjections.add(projection);
  }

  public void addReturnItem(SQLExpression item) {
    this.returnItems.add(item);
  }

  public void addReturnAlias(SQLIdentifier alias) {
    this.returnAliases.add(alias);
  }

  public static class MatchContext {

    int currentEdgeNumber = 0;

    Map<String, Iterable> candidates = new LinkedHashMap<String, Iterable>();
    Map<String, Identifiable> matched = new LinkedHashMap<String, Identifiable>();
    Map<PatternEdge, Boolean> matchedEdges = new IdentityHashMap<PatternEdge, Boolean>();

    public MatchContext copy(String alias, Identifiable value) {
      var result = new MatchContext();

      result.candidates.putAll(candidates);
      result.candidates.remove(alias);

      result.matched.putAll(matched);
      result.matched.put(alias, value);

      result.matchedEdges.putAll(matchedEdges);
      result.currentEdgeNumber = currentEdgeNumber;
      return result;
    }

    public EntityImpl toEntity(DatabaseSessionInternal db) {
      var entity = new EntityImpl(null);
      entity.updateFromMap(matched);
      return entity;
    }
  }

  public static class EdgeTraversal {

    private boolean out = true;
    private final PatternEdge edge;

    public EdgeTraversal(PatternEdge edge, boolean out) {
      this.edge = edge;
      this.out = out;
    }
  }

  public static class MatchExecutionPlan {

    public List<EdgeTraversal> sortedEdges;
    public Map<String, Long> preFetchedAliases = new HashMap<String, Long>();
    public String rootAlias;
  }

  public SQLMatchStatement() {
    super(-1);
  }

  public SQLMatchStatement(int id) {
    super(id);
  }

  public SQLMatchStatement(YouTrackDBSql p, int id) {
    super(p, id);
  }

  @Override
  public ResultSet execute(
      DatabaseSessionInternal session, Object[] args, CommandContext parentCtx,
      boolean usePlanCache) {
    var ctx = new BasicCommandContext();
    if (parentCtx != null) {
      ctx.setParentWithoutOverridingChild(parentCtx);
    }
    ctx.setDatabaseSession(session);
    Map<Object, Object> params = new HashMap<>();
    if (args != null) {
      for (var i = 0; i < args.length; i++) {
        params.put(i, args[i]);
      }
    }
    ctx.setInputParameters(params);
    InternalExecutionPlan executionPlan;
    if (usePlanCache) {
      executionPlan = createExecutionPlan(ctx, false);
    } else {
      executionPlan = createExecutionPlanNoCache(ctx, false);
    }

    return new LocalResultSet(session, executionPlan);
  }

  @Override
  public ResultSet execute(
      DatabaseSessionInternal session, Map<Object, Object> params, CommandContext parentCtx,
      boolean usePlanCache) {
    var ctx = new BasicCommandContext();
    if (parentCtx != null) {
      ctx.setParentWithoutOverridingChild(parentCtx);
    }
    ctx.setDatabaseSession(session);
    ctx.setInputParameters(params);
    InternalExecutionPlan executionPlan;
    if (usePlanCache) {
      executionPlan = createExecutionPlan(ctx, false);
    } else {
      executionPlan = createExecutionPlanNoCache(ctx, false);
    }

    return new LocalResultSet(session, executionPlan);
  }

  public InternalExecutionPlan createExecutionPlan(CommandContext ctx, boolean enableProfiling) {
    var planner = new MatchExecutionPlanner(this);
    var result = planner.createExecutionPlan(ctx, enableProfiling);
    result.setStatement(originalStatement);
    result.setGenericStatement(this.toGenericStatement());
    return result;
  }

  // ------------------------------------------------------------------
  // query parsing and optimization
  // ------------------------------------------------------------------
  void buildPatterns() {
    assignDefaultAliases(this.matchExpressions);
    pattern = new Pattern();
    for (var expr : this.matchExpressions) {
      pattern.addExpression(expr);
    }

    Map<String, SQLWhereClause> aliasFilters = new LinkedHashMap<String, SQLWhereClause>();
    Map<String, String> aliasClasses = new LinkedHashMap<String, String>();
    for (var expr : this.matchExpressions) {
      addAliases(expr, aliasFilters, aliasClasses, context);
    }

    this.aliasFilters = aliasFilters;

    rebindFilters(aliasFilters);
  }

  /**
   * rebinds filter (where) conditions to alias nodes after optimization
   *
   * @param aliasFilters
   */
  private void rebindFilters(Map<String, SQLWhereClause> aliasFilters) {
    for (var expression : matchExpressions) {
      var newFilter = aliasFilters.get(expression.origin.getAlias());
      expression.origin.setFilter(newFilter);

      for (var item : expression.items) {
        newFilter = aliasFilters.get(item.filter.getAlias());
        item.filter.setFilter(newFilter);
      }
    }
  }

  /**
   * assigns default aliases to pattern nodes that do not have an explicit alias
   *
   * @param matchExpressions
   */
  private void assignDefaultAliases(List<SQLMatchExpression> matchExpressions) {
    var counter = 0;
    for (var expression : matchExpressions) {
      if (expression.origin.getAlias() == null) {
        expression.origin.setAlias(DEFAULT_ALIAS_PREFIX + (counter++));
      }

      for (var item : expression.items) {
        if (item.filter == null) {
          item.filter = new SQLMatchFilter(-1);
        }
        if (item.filter.getAlias() == null) {
          item.filter.setAlias(DEFAULT_ALIAS_PREFIX + (counter++));
        }
      }
    }
  }

  /**
   * Start a depth-first traversal from the starting node, adding all viable unscheduled edges and
   * vertices.
   *
   * @param startNode             the node from which to start the depth-first traversal
   * @param visitedNodes          set of nodes that are already visited (mutated in this function)
   * @param visitedEdges          set of edges that are already visited and therefore don't need to
   *                              be scheduled (mutated in this function)
   * @param remainingDependencies dependency map including only the dependencies that haven't yet
   *                              been satisfied (mutated in this function)
   * @param resultingSchedule     the schedule being computed i.e. appended to (mutated in this
   *                              function)
   */
  private static void updateScheduleStartingAt(
      PatternNode startNode,
      Set<PatternNode> visitedNodes,
      Set<PatternEdge> visitedEdges,
      Map<String, Set<String>> remainingDependencies,
      List<EdgeTraversal> resultingSchedule) {
    // YouTrackDB requires the schedule to contain all edges present in the query, which is a stronger
    // condition
    // than simply visiting all nodes in the query. Consider the following example query:
    //     MATCH {
    //         class: A,
    //         as: foo
    //     }.in() {
    //         as: bar
    //     }, {
    //         class: B,
    //         as: bar
    //     }.out() {
    //         as: foo
    //     } RETURN $matches
    // The schedule for the above query must have two edges, even though there are only two nodes
    // and they can both
    // be visited with the traversal of a single edge.
    //
    // To satisfy it, we obey the following for each non-optional node:
    // - ignore edges to neighboring nodes which have unsatisfied dependencies;
    // - for visited neighboring nodes, add their edge if it wasn't already present in the schedule,
    // but do not
    //   recurse into the neighboring node;
    // - for unvisited neighboring nodes with satisfied dependencies, add their edge and recurse
    // into them.
    visitedNodes.add(startNode);
    for (var dependencies : remainingDependencies.values()) {
      dependencies.remove(startNode.alias);
    }

    Map<PatternEdge, Boolean> edges = new LinkedHashMap<PatternEdge, Boolean>();
    for (var outEdge : startNode.out) {
      edges.put(outEdge, true);
    }
    for (var inEdge : startNode.in) {
      edges.put(inEdge, false);
    }

    for (var edgeData : edges.entrySet()) {
      var edge = edgeData.getKey();
      boolean isOutbound = edgeData.getValue();
      var neighboringNode = isOutbound ? edge.in : edge.out;

      if (!remainingDependencies.get(neighboringNode.alias).isEmpty()) {
        // Unsatisfied dependencies, ignore this neighboring node.
        continue;
      }

      if (visitedNodes.contains(neighboringNode)) {
        if (!visitedEdges.contains(edge)) {
          // If we are executing in this block, we are in the following situation:
          // - the startNode has not been visited yet;
          // - it has a neighboringNode that has already been visited;
          // - the edge between the startNode and the neighboringNode has not been scheduled yet.
          //
          // The isOutbound value shows us whether the edge is outbound from the point of view of
          // the startNode.
          // However, if there are edges to the startNode, we must visit the startNode from an
          // already-visited
          // neighbor, to preserve the validity of the traversal. Therefore, we negate the value of
          // isOutbound
          // to ensure that the edge is always scheduled in the direction from the already-visited
          // neighbor
          // toward the startNode. Notably, this is also the case when evaluating "optional" nodes
          // -- we always
          // visit the optional node from its non-optional and already-visited neighbor.
          //
          // The only exception to the above is when we have edges with "while" conditions. We are
          // not allowed
          // to flip their directionality, so we leave them as-is.
          boolean traversalDirection;
          if (startNode.optional || edge.item.isBidirectional()) {
            traversalDirection = !isOutbound;
          } else {
            traversalDirection = isOutbound;
          }

          visitedEdges.add(edge);
          resultingSchedule.add(new EdgeTraversal(edge, traversalDirection));
        }
      } else if (!startNode.optional) {
        // If the neighboring node wasn't visited, we don't expand the optional node into it, hence
        // the above check.
        // Instead, we'll allow the neighboring node to add the edge we failed to visit, via the
        // above block.
        if (visitedEdges.contains(edge)) {
          // Should never happen.
          throw new AssertionError(
              "The edge was visited, but the neighboring vertex was not: "
                  + edge
                  + " "
                  + neighboringNode);
        }

        visitedEdges.add(edge);
        resultingSchedule.add(new EdgeTraversal(edge, isOutbound));
        updateScheduleStartingAt(
            neighboringNode, visitedNodes, visitedEdges, remainingDependencies, resultingSchedule);
      }
    }
  }

  /**
   * Calculate the set of dependency aliases for each alias in the pattern.
   *
   * @param pattern
   * @return map of alias to the set of aliases it depends on
   */
  private Map<String, Set<String>> getDependencies(Pattern pattern) {
    Map<String, Set<String>> result = new HashMap<String, Set<String>>();

    for (var node : pattern.aliasToNode.values()) {
      Set<String> currentDependencies = new HashSet<String>();

      var filter = aliasFilters.get(node.alias);
      if (filter != null && filter.baseExpression != null) {
        var involvedAliases = filter.baseExpression.getMatchPatternInvolvedAliases();
        if (involvedAliases != null) {
          currentDependencies.addAll(involvedAliases);
        }
      }

      result.put(node.alias, currentDependencies);
    }

    return result;
  }

  /**
   * sort edges in the order they will be matched
   */
  private List<EdgeTraversal> getTopologicalSortedSchedule(
      Map<String, Long> estimatedRootEntries, Pattern pattern) {
    List<EdgeTraversal> resultingSchedule = new ArrayList<EdgeTraversal>();
    var remainingDependencies = getDependencies(pattern);
    Set<PatternNode> visitedNodes = new HashSet<PatternNode>();
    Set<PatternEdge> visitedEdges = new HashSet<PatternEdge>();

    // Sort the possible root vertices in order of estimated size, since we want to start with a
    // small vertex set.
    List<PairLongObject<String>> rootWeights = new ArrayList<>();
    for (var root : estimatedRootEntries.entrySet()) {
      rootWeights.add(new PairLongObject<>(root.getValue(), root.getKey()));
    }
    Collections.sort(rootWeights);

    // Add the starting vertices, in the correct order, to an ordered set.
    Set<String> remainingStarts = new LinkedHashSet<String>();
    for (var item : rootWeights) {
      remainingStarts.add(item.getValue());
    }
    // Add all the remaining aliases after all the suggested start points.
    remainingStarts.addAll(pattern.aliasToNode.keySet());

    while (resultingSchedule.size() < pattern.numOfEdges) {
      // Start a new depth-first pass, adding all nodes with satisfied dependencies.
      // 1. Find a starting vertex for the depth-first pass.
      PatternNode startingNode = null;
      List<String> startsToRemove = new ArrayList<String>();
      for (var currentAlias : remainingStarts) {
        var currentNode = pattern.aliasToNode.get(currentAlias);

        if (visitedNodes.contains(currentNode)) {
          // If a previous traversal already visited this alias, remove it from further
          // consideration.
          startsToRemove.add(currentAlias);
        } else if (remainingDependencies.get(currentAlias).isEmpty()) {
          // If it hasn't been visited, and has all dependencies satisfied, visit it.
          startsToRemove.add(currentAlias);
          startingNode = currentNode;
          break;
        }
      }
      remainingStarts.removeAll(startsToRemove);

      if (startingNode == null) {
        // We didn't manage to find a valid root, and yet we haven't constructed a complete
        // schedule.
        // This means there must be a cycle in our dependency graph, or all dependency-free nodes
        // are optional.
        // Therefore, the query is invalid.
        throw new CommandExecutionException(
            "This query contains MATCH conditions that cannot be evaluated, "
                + "like an undefined alias or a circular dependency on a $matched condition.");
      }

      // 2. Having found a starting vertex, traverse its neighbors depth-first,
      //    adding any non-visited ones with satisfied dependencies to our schedule.
      updateScheduleStartingAt(
          startingNode, visitedNodes, visitedEdges, remainingDependencies, resultingSchedule);
    }

    if (resultingSchedule.size() != pattern.numOfEdges) {
      throw new AssertionError(
          "Incorrect number of edges: " + resultingSchedule.size() + " vs " + pattern.numOfEdges);
    }

    return resultingSchedule;
  }


  private boolean calculateMatch(
      Pattern pattern,
      Map<String, Long> estimatedRootEntries,
      MatchContext matchContext,
      Map<String, String> aliasClasses,
      Map<String, SQLWhereClause> aliasFilters,
      CommandContext iCommandContext,
      SQLAsynchQuery<EntityImpl> request,
      MatchExecutionPlan executionPlan) {

    var db = iCommandContext.getDatabaseSession();
    var rootFound = false;
    // find starting nodes with few entries
    for (var entryPoint : estimatedRootEntries.entrySet()) {
      if (entryPoint.getValue() < threshold) {
        var nextAlias = entryPoint.getKey();
        var matches =
            fetchAliasCandidates(nextAlias, aliasFilters, iCommandContext, aliasClasses);

        if (!matches.iterator().hasNext()) {
          if (pattern.get(nextAlias).isOptionalNode()) {
            continue;
          }
          return true;
        }

        matchContext.candidates.put(nextAlias, matches);
        executionPlan.preFetchedAliases.put(nextAlias, entryPoint.getValue());
        rootFound = true;
      }
    }
    // no nodes under threshold, guess the smallest one
    if (!rootFound) {
      var nextAlias = getNextAlias(estimatedRootEntries, matchContext);
      var matches =
          fetchAliasCandidates(nextAlias, aliasFilters, iCommandContext, aliasClasses);
      if (!matches.iterator().hasNext()) {
        return true;
      }
      matchContext.candidates.put(nextAlias, matches);
      executionPlan.preFetchedAliases.put(nextAlias, estimatedRootEntries.get(nextAlias));
    }

    // pick first edge (as sorted before)
    var firstEdge =
        executionPlan.sortedEdges.size() == 0 ? null : executionPlan.sortedEdges.get(0);
    String smallestAlias = null;
    // and choose the most convenient starting point (the most convenient traversal direction)
    if (firstEdge != null) {
      smallestAlias = firstEdge.out ? firstEdge.edge.out.alias : firstEdge.edge.in.alias;
    } else {
      smallestAlias = pattern.aliasToNode.values().iterator().next().alias;
    }
    executionPlan.rootAlias = smallestAlias;
    Iterable<Identifiable> allCandidates = matchContext.candidates.get(smallestAlias);

    if (allCandidates == null) {
      var select =
          buildSelectStatement(aliasClasses.get(smallestAlias), aliasFilters.get(smallestAlias));
      allCandidates = (Iterable) db.query(new SQLSynchQuery<Object>(select.toString()));
    }

    return processContextFromCandidates(
        pattern,
        executionPlan,
        matchContext,
        aliasClasses,
        aliasFilters,
        iCommandContext,
        request,
        allCandidates,
        smallestAlias,
        0);
  }

  private boolean processContextFromCandidates(
      Pattern pattern,
      MatchExecutionPlan executionPlan,
      MatchContext matchContext,
      Map<String, String> aliasClasses,
      Map<String, SQLWhereClause> aliasFilters,
      CommandContext iCommandContext,
      SQLAsynchQuery<EntityImpl> request,
      Iterable<Identifiable> candidates,
      String alias,
      int startFromEdge) {
    for (var id : candidates) {
      var childContext = matchContext.copy(alias, id);
      childContext.currentEdgeNumber = startFromEdge;
      if (!processContext(
          pattern,
          executionPlan,
          childContext,
          aliasClasses,
          aliasFilters,
          iCommandContext,
          request)) {
        return false;
      }
    }
    return true;
  }

  private Iterable<Identifiable> fetchAliasCandidates(
      String nextAlias,
      Map<String, SQLWhereClause> aliasFilters,
      CommandContext iCommandContext,
      Map<String, String> aliasClasses) {
    var it =
        query(aliasClasses.get(nextAlias), aliasFilters.get(nextAlias), iCommandContext);
    Set<Identifiable> result = new HashSet<Identifiable>();
    while (it.hasNext()) {
      result.add(it.next().getIdentity());
    }

    return result;
  }

  private boolean processContext(
      Pattern pattern,
      MatchExecutionPlan executionPlan,
      MatchContext matchContext,
      Map<String, String> aliasClasses,
      Map<String, SQLWhereClause> aliasFilters,
      CommandContext iCommandContext,
      SQLAsynchQuery<EntityImpl> request) {

    var db = iCommandContext.getDatabaseSession();
    iCommandContext.setVariable("$matched", matchContext.matched);

    if (pattern.getNumOfEdges() == matchContext.matchedEdges.size()
        && allNodesCalculated(matchContext, pattern)) {
      // false if limit reached
      return addResult(matchContext, request, iCommandContext);
    }
    if (executionPlan.sortedEdges.size() == matchContext.currentEdgeNumber) {
      // false if limit reached
      return expandCartesianProduct(
          pattern, matchContext, aliasClasses, aliasFilters, iCommandContext, request);
    }
    var currentEdge = executionPlan.sortedEdges.get(matchContext.currentEdgeNumber);
    var rootNode = currentEdge.out ? currentEdge.edge.out : currentEdge.edge.in;

    if (currentEdge.out) {
      var outEdge = currentEdge.edge;

      if (!matchContext.matchedEdges.containsKey(outEdge)) {

        var startingPoint = matchContext.matched.get(outEdge.out.alias);
        if (startingPoint == null) {
          // restart from candidates (disjoint patterns? optional? just could not proceed from last
          // node?)
          var rightCandidates = matchContext.candidates.get(outEdge.out.alias);
          if (rightCandidates != null) {
            return processContextFromCandidates(
                pattern,
                executionPlan,
                matchContext,
                aliasClasses,
                aliasFilters,
                iCommandContext,
                request,
                rightCandidates,
                outEdge.out.alias,
                matchContext.currentEdgeNumber);
          }
          return true;
        }
        Object rightValues =
            outEdge.executeTraversal(matchContext, iCommandContext, startingPoint, 0);

        if (outEdge.in.isOptionalNode()
            && (isEmptyResult(rightValues)
            || !contains(rightValues, matchContext.matched.get(outEdge.in.alias)))) {
          var childContext = matchContext.copy(outEdge.in.alias, null);
          childContext.matched.put(outEdge.in.alias, null);
          childContext.currentEdgeNumber =
              matchContext.currentEdgeNumber + 1; // TODO testOptional 3 match passa con +1
          childContext.matchedEdges.put(outEdge, true);

          if (!processContext(
              pattern,
              executionPlan,
              childContext,
              aliasClasses,
              aliasFilters,
              iCommandContext,
              request)) {
            return false;
          }
        }
        if (!(rightValues instanceof Iterable)) {
          rightValues = Collections.singleton(rightValues);
        }
        var rightClassName = aliasClasses.get(outEdge.in.alias);
        var rightClass = db.getMetadata().getSchema().getClass(rightClassName);
        for (var rightValue : (Iterable<Identifiable>) rightValues) {
          if (rightValue == null) {
            continue; // broken graph?, null reference
          }

          if (rightClass != null && !matchesClass(db, rightValue, rightClass)) {
            continue;
          }
          Iterable<Identifiable> prevMatchedRightValues =
              matchContext.candidates.get(outEdge.in.alias);

          if (matchContext.matched.containsKey(outEdge.in.alias)) {
            if (matchContext
                .matched
                .get(outEdge.in.alias)
                .getIdentity()
                .equals(rightValue.getIdentity())) {
              var childContext =
                  matchContext.copy(outEdge.in.alias, rightValue.getIdentity());
              childContext.currentEdgeNumber = matchContext.currentEdgeNumber + 1;
              childContext.matchedEdges.put(outEdge, true);
              if (!processContext(
                  pattern,
                  executionPlan,
                  childContext,
                  aliasClasses,
                  aliasFilters,
                  iCommandContext,
                  request)) {
                return false;
              }
              break;
            }
          } else if (prevMatchedRightValues != null
              && prevMatchedRightValues.iterator().hasNext()) { // just matching against
            // known
            // values
            for (var id : prevMatchedRightValues) {
              if (id.getIdentity().equals(rightValue.getIdentity())) {
                var childContext = matchContext.copy(outEdge.in.alias, id);
                childContext.currentEdgeNumber = matchContext.currentEdgeNumber + 1;
                childContext.matchedEdges.put(outEdge, true);
                if (!processContext(
                    pattern,
                    executionPlan,
                    childContext,
                    aliasClasses,
                    aliasFilters,
                    iCommandContext,
                    request)) {
                  return false;
                }
              }
            }
          } else { // searching for neighbors
            var childContext =
                matchContext.copy(outEdge.in.alias, rightValue.getIdentity());
            childContext.currentEdgeNumber = matchContext.currentEdgeNumber + 1;
            childContext.matchedEdges.put(outEdge, true);
            if (!processContext(
                pattern,
                executionPlan,
                childContext,
                aliasClasses,
                aliasFilters,
                iCommandContext,
                request)) {
              return false;
            }
          }
        }
      }
    } else {
      var inEdge = currentEdge.edge;
      if (!matchContext.matchedEdges.containsKey(inEdge)) {
        if (!inEdge.item.isBidirectional()) {
          throw new RuntimeException("Invalid pattern to match!");
        }
        if (!matchContext.matchedEdges.containsKey(inEdge)) {
          var leftValues =
              inEdge.item.method.executeReverse(
                  matchContext.matched.get(inEdge.in.alias), iCommandContext);
          if (inEdge.out.isOptionalNode()
              && (isEmptyResult(leftValues)
              || !contains(leftValues, matchContext.matched.get(inEdge.out.alias)))) {
            var childContext = matchContext.copy(inEdge.out.alias, null);
            childContext.matched.put(inEdge.out.alias, null);
            childContext.currentEdgeNumber = matchContext.currentEdgeNumber + 1;
            childContext.matchedEdges.put(inEdge, true);
            if (!processContext(
                pattern,
                executionPlan,
                childContext,
                aliasClasses,
                aliasFilters,
                iCommandContext,
                request)) {
              return false;
            }
          }
          if (leftValues instanceof Identifiable || !(leftValues instanceof Iterable)) {
            leftValues = Collections.singleton(leftValues);
          }

          var leftClassName = aliasClasses.get(inEdge.out.alias);
          var leftClass = db.getMetadata().getSchema().getClass(leftClassName);

          for (var leftValue : (Iterable<Identifiable>) leftValues) {
            if (leftValue == null) {
              continue; // broken graph? null reference
            }

            if (leftClass != null && !matchesClass(db, leftValue, leftClass)) {
              continue;
            }
            Iterable<Identifiable> prevMatchedRightValues =
                matchContext.candidates.get(inEdge.out.alias);

            if (matchContext.matched.containsKey(inEdge.out.alias)) {
              if (matchContext
                  .matched
                  .get(inEdge.out.alias)
                  .getIdentity()
                  .equals(leftValue.getIdentity())) {
                var childContext =
                    matchContext.copy(inEdge.out.alias, leftValue.getIdentity());
                childContext.currentEdgeNumber = matchContext.currentEdgeNumber + 1;
                childContext.matchedEdges.put(inEdge, true);
                if (!processContext(
                    pattern,
                    executionPlan,
                    childContext,
                    aliasClasses,
                    aliasFilters,
                    iCommandContext,
                    request)) {
                  return false;
                }
                break;
              }
            } else if (prevMatchedRightValues != null
                && prevMatchedRightValues.iterator().hasNext()) { // just matching against
              // known
              // values
              for (var id : prevMatchedRightValues) {
                if (id.getIdentity().equals(leftValue.getIdentity())) {
                  var childContext = matchContext.copy(inEdge.out.alias, id);
                  childContext.currentEdgeNumber = matchContext.currentEdgeNumber + 1;
                  childContext.matchedEdges.put(inEdge, true);

                  if (!processContext(
                      pattern,
                      executionPlan,
                      childContext,
                      aliasClasses,
                      aliasFilters,
                      iCommandContext,
                      request)) {
                    return false;
                  }
                }
              }
            } else { // searching for neighbors
              var where = aliasFilters.get(inEdge.out.alias);
              var className = aliasClasses.get(inEdge.out.alias);
              var oClass = db.getMetadata().getSchema().getClass(className);
              if ((oClass == null || matchesClass(db, leftValue, oClass))
                  && (where == null || where.matchesFilters(leftValue, iCommandContext))) {
                var childContext =
                    matchContext.copy(inEdge.out.alias, leftValue.getIdentity());
                childContext.currentEdgeNumber = matchContext.currentEdgeNumber + 1;
                childContext.matchedEdges.put(inEdge, true);
                if (!processContext(
                    pattern,
                    executionPlan,
                    childContext,
                    aliasClasses,
                    aliasFilters,
                    iCommandContext,
                    request)) {
                  return false;
                }
              }
            }
          }
        }
      }
    }
    return true;
  }

  private static boolean matchesClass(DatabaseSessionInternal db, Identifiable identifiable,
      SchemaClass oClass) {
    if (identifiable == null) {
      return false;
    }
    try {
      var record = identifiable.getRecord(db);
      if (record instanceof EntityImpl) {
        SchemaClass schemaClass = EntityInternalUtils.getImmutableSchemaClass(
            ((EntityImpl) record));
        if (schemaClass == null) {
          return false;
        }
        return schemaClass.isSubClassOf(db, oClass);
      }
      return false;
    } catch (RecordNotFoundException rnf) {
      return false;
    }
  }

  private boolean contains(Object rightValues, Identifiable oIdentifiable) {
    if (oIdentifiable == null) {
      return true;
    }
    if (rightValues == null) {
      return false;
    }
    if (rightValues instanceof Identifiable) {
      return ((Identifiable) rightValues).getIdentity().equals(oIdentifiable.getIdentity());
    }
    Iterator iterator = null;
    if (rightValues instanceof Iterable) {
      iterator = ((Iterable) rightValues).iterator();
    }
    if (rightValues instanceof Iterator) {
      iterator = (Iterator) rightValues;
    }
    if (iterator != null) {
      while (iterator.hasNext()) {
        var next = iterator.next();
        if (next instanceof Identifiable) {
          if (((Identifiable) next).getIdentity().equals(oIdentifiable.getIdentity())) {
            return true;
          }
        }
      }
    }
    return false;
  }

  private boolean isEmptyResult(Object rightValues) {
    if (rightValues == null) {
      return true;
    }
    if (rightValues instanceof Iterable) {
      var iterator = ((Iterable) rightValues).iterator();
      if (!iterator.hasNext()) {
        return true;
      }
      while (iterator.hasNext()) {
        var nextElement = iterator.next();
        if (nextElement != null) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  private boolean expandCartesianProduct(
      Pattern pattern,
      MatchContext matchContext,
      Map<String, String> aliasClasses,
      Map<String, SQLWhereClause> aliasFilters,
      CommandContext iCommandContext,
      SQLAsynchQuery<EntityImpl> request) {
    for (var alias : pattern.aliasToNode.keySet()) {
      if (!matchContext.matched.containsKey(alias)) {
        var target = aliasClasses.get(alias);
        if (target == null) {
          throw new CommandExecutionException(iCommandContext.getDatabaseSession(),
              "Cannot execute MATCH statement on alias " + alias + ": class not defined");
        }

        var values =
            fetchAliasCandidates(alias, aliasFilters, iCommandContext, aliasClasses);
        for (var id : values) {
          var childContext = matchContext.copy(alias, id);
          if (allNodesCalculated(childContext, pattern)) {
            // false if limit reached
            var added = addResult(childContext, request, iCommandContext);
            if (!added) {
              return false;
            }
          } else {
            // false if limit reached
            var added =
                expandCartesianProduct(
                    pattern, childContext, aliasClasses, aliasFilters, iCommandContext, request);
            if (!added) {
              return false;
            }
          }
        }
        break;
      }
    }
    return true;
  }

  private boolean allNodesCalculated(MatchContext matchContext, Pattern pattern) {
    for (var alias : pattern.aliasToNode.keySet()) {
      if (!matchContext.matched.containsKey(alias)) {
        return false;
      }
    }
    return true;
  }

  private boolean addResult(
      MatchContext matchContext, SQLAsynchQuery<EntityImpl> request, CommandContext ctx) {

    var db = ctx.getDatabaseSession();
    EntityImpl entity = null;
    if (returnsElements()) {
      for (var entry : matchContext.matched.entrySet()) {
        if (isExplicitAlias(entry.getKey()) && entry.getValue() != null) {
          try {
            var record = entry.getValue().getRecord(db);
            if (request.getResultListener() != null) {
              if (!addSingleResult(request, (BasicCommandContext) ctx, record)) {
                return false;
              }
            }
          } catch (RecordNotFoundException rnf) {
            return false;
          }
        }
      }
    } else if (returnsPathElements()) {
      for (var entry : matchContext.matched.entrySet()) {
        if (entry.getValue() != null) {
          try {
            var record = entry.getValue().getRecord(db);
            if (request.getResultListener() != null) {
              if (!addSingleResult(request, (BasicCommandContext) ctx, record)) {
                return false;
              }
            }
          } catch (RecordNotFoundException rnf) {
            return false;
          }
        }
      }
    } else if (returnsPatterns()) {
      entity = db.newInstance();
      entity.setTrackingChanges(false);
      for (var entry : matchContext.matched.entrySet()) {
        if (isExplicitAlias(entry.getKey())) {
          entity.field(entry.getKey(), entry.getValue());
        }
      }
    } else if (returnsPaths()) {
      entity = db.newInstance();
      entity.setTrackingChanges(false);
      for (var entry : matchContext.matched.entrySet()) {
        entity.field(entry.getKey(), entry.getValue());
      }
    } else if (returnsJson()) {
      entity = jsonToDoc(matchContext, ctx);
    } else {
      entity = db.newInstance();
      entity.setTrackingChanges(false);
      var i = 0;

      var mapDoc = new EntityImpl(null);
      mapDoc.setTrackingChanges(false);
      mapDoc.updateFromMap(matchContext.matched);
      ctx.setVariable("$current", mapDoc);
      for (var item : returnItems) {
        var returnAliasIdentifier = returnAliases.get(i);
        SQLIdentifier returnAlias;
        if (returnAliasIdentifier == null) {
          returnAlias = item.getDefaultAlias();
        } else {
          returnAlias = returnAliasIdentifier;
        }
        var executed = item.execute(mapDoc, ctx);
        // Force Embedded Document
        if (executed instanceof EntityImpl && !((EntityImpl) executed).getIdentity()
            .isValid()) {
          entity.setProperty(returnAlias.getStringValue(), executed, PropertyType.EMBEDDED);
        } else {
          entity.setProperty(returnAlias.getStringValue(), executed);
        }
        i++;
      }
      entity.setTrackingChanges(true);
    }

    if (request.getResultListener() != null && entity != null) {
      return addSingleResult(request, (BasicCommandContext) ctx, entity);
    }

    return true;
  }

  /**
   * @param request
   * @param ctx
   * @param record
   * @return false if limit was reached
   */
  private boolean addSingleResult(
      SQLAsynchQuery<EntityImpl> request, BasicCommandContext ctx, DBRecord record) {
    if (((BasicCommandContext) context).addToUniqueResult(record)) {
      request.getResultListener().result(ctx.getDatabaseSession(), record);
      var currentCount = ctx.getResultsProcessed().incrementAndGet();
      long limitValue = limitFromProtocol;
      if (limit != null) {
        limitValue = limit.num.getValue().longValue();
      }
      return limitValue <= -1 || limitValue > currentCount;
    }
    return true;
  }

  public boolean returnsPathElements() {
    for (var item : returnItems) {
      if (item.toString().equalsIgnoreCase("$pathElements")) {
        return true;
      }
    }
    return false;
  }

  public boolean returnsElements() {
    for (var item : returnItems) {
      if (item.toString().equalsIgnoreCase("$elements")) {
        return true;
      }
    }
    return false;
  }

  public boolean returnsPatterns() {
    for (var item : returnItems) {
      if (item.toString().equalsIgnoreCase("$patterns")) {
        return true;
      }
      if (item.toString().equalsIgnoreCase("$matches")) {
        return true;
      }
    }
    return false;
  }

  public boolean returnsPaths() {
    for (var item : returnItems) {
      if (item.toString().equalsIgnoreCase("$paths")) {
        return true;
      }
    }
    return false;
  }

  private boolean returnsJson() {
    return returnItems.size() == 1
        && (returnItems.get(0).value instanceof SQLJson)
        && returnAliases.get(0) == null;
  }

  private EntityImpl jsonToDoc(MatchContext matchContext, CommandContext ctx) {
    if (returnItems.size() == 1
        && (returnItems.get(0).value instanceof SQLJson)
        && returnAliases.get(0) == null) {
      var db = ctx.getDatabaseSession();
      var result = new EntityImpl(null);
      result.setTrackingChanges(false);
      result.updateFromMap(
          ((SQLJson) returnItems.get(0).value).toMap(matchContext.toEntity(db), ctx));
      return result;
    }
    throw new IllegalStateException("Match RETURN statement is not a plain JSON");
  }

  private boolean isExplicitAlias(String key) {
    return !key.startsWith(DEFAULT_ALIAS_PREFIX);
  }

  private Iterator<Identifiable> query(
      String className, SQLWhereClause oWhereClause, CommandContext ctx) {
    final var database = ctx.getDatabaseSession();
    var schemaClass = database.getMetadata().getSchema().getClass(className);
    database.checkSecurity(
        Rule.ResourceGeneric.CLASS,
        Role.PERMISSION_READ,
        schemaClass.getName(database).toLowerCase(Locale.ENGLISH));

    String text;
    if (oWhereClause == null) {
      text = "(select from " + className + ")";
    } else {
      var builder = new StringBuilder();
      oWhereClause.toString(ctx.getInputParameters(), builder);

      // TODO make it more OO!
      //      synchronized (oWhereClause) { //this instance is shared...
      //        replaceIdentifier(oWhereClause, "$currentMatch", "@this"); //
      //        newWhere = oWhereClause.replaceIdentifier("$currentMatch", "@this");
      text =
          "(select from "
              + className
              + " where "
              + builder.toString().replaceAll("\\$currentMatch", "@this")
              + ")";
      //        replaceIdentifier(oWhereClause, "@this", "$currentMatch");
      //      }
    }
    var target = new SQLTarget(text, ctx);
    Iterable targetResult = target.getTargetRecords();
    if (targetResult == null) {
      return null;
    }

    if (targetResult instanceof CommandExecutorSQLSelect) {
      ((CommandExecutorSQLSelect) targetResult)
          .getContext()
          .setRecordingMetrics(ctx.isRecordingMetrics());
    } else if (targetResult instanceof CommandExecutorSQLResultsetDelegate) {
      var delegate =
          ((CommandExecutorSQLResultsetDelegate) targetResult).getDelegate();
      if (delegate instanceof CommandExecutorSQLSelect) {
        delegate.getContext().setRecordingMetrics(ctx.isRecordingMetrics());
      }
    }
    return targetResult.iterator();
  }

  //  private void replaceIdentifier(SimpleNode node, String from, String to) {
  //    if (node instanceof SQLIdentifier) {
  //      if (from.equals(node.getValue())) {
  //        ((SQLIdentifier) node).setStringValue(to);
  //      }
  //    } else {
  //      for (int i = 0; i < node.jjtGetNumChildren(); i++) {
  //        replaceIdentifier((SimpleNode) node.jjtGetChild(i), from, to);
  //      }
  //    }
  //
  //  }

  private SQLSelectStatement buildSelectStatement(String className, SQLWhereClause oWhereClause) {
    var stm = new SQLSelectStatement(-1);
    stm.whereClause = oWhereClause;
    stm.target = new SQLFromClause(-1);
    stm.target.item = new SQLFromItem(-1);
    stm.target.item.identifier = new SQLIdentifier(className);
    return stm;
  }

  private Iterable<DBRecord> fetchFromIndex(SchemaClass schemaClass, SQLWhereClause oWhereClause) {
    return null; // TODO
  }

  private String getNextAlias(Map<String, Long> estimatedRootEntries, MatchContext matchContext) {
    Map.Entry<String, Long> lowerValue = null;
    for (var entry : estimatedRootEntries.entrySet()) {
      if (matchContext.matched.containsKey(entry.getKey())) {
        continue;
      }
      if (lowerValue == null) {
        lowerValue = entry;
      } else if (lowerValue.getValue() > entry.getValue()) {
        lowerValue = entry;
      }
    }

    if (lowerValue == null) {
      throw new CommandExecutionException(
          "Cannot calculate this pattern (maybe a circular dependency on $matched conditions)");
    }
    return lowerValue.getKey();
  }

  private Map<String, Long> estimateRootEntries(
      Map<String, String> aliasClasses,
      Map<String, SQLWhereClause> aliasFilters,
      CommandContext ctx) {
    Set<String> allAliases = new LinkedHashSet<String>();
    allAliases.addAll(aliasClasses.keySet());
    allAliases.addAll(aliasFilters.keySet());

    var db = ctx.getDatabaseSession();
    var schema = db.getMetadata().getImmutableSchemaSnapshot();

    Map<String, Long> result = new LinkedHashMap<String, Long>();
    for (var alias : allAliases) {
      var className = aliasClasses.get(alias);
      if (className == null) {
        continue;
      }

      if (!schema.existsClass(className)) {
        throw new CommandExecutionException("class not defined: " + className);
      }
      var oClass = schema.getClassInternal(className);
      long upperBound;
      var filter = aliasFilters.get(alias);
      if (filter != null) {
        var aliasesOnPattern = filter.baseExpression.getMatchPatternInvolvedAliases();
        if (aliasesOnPattern != null && !aliasesOnPattern.isEmpty()) {
          // skip root nodes that have a condition on $matched, because they have to be calculated
          // as downstream
          continue;
        }
        upperBound = filter.estimate(oClass, this.threshold, ctx);
      } else {
        upperBound = oClass.count(db);
      }
      result.put(alias, upperBound);
    }
    return result;
  }

  private void addAliases(
      SQLMatchExpression expr,
      Map<String, SQLWhereClause> aliasFilters,
      Map<String, String> aliasClasses,
      CommandContext context) {
    addAliases(expr.origin, aliasFilters, aliasClasses, context);
    for (var item : expr.items) {
      if (item.filter != null) {
        addAliases(item.filter, aliasFilters, aliasClasses, context);
      }
    }
  }

  private void addAliases(
      SQLMatchFilter matchFilter,
      Map<String, SQLWhereClause> aliasFilters,
      Map<String, String> aliasClasses,
      CommandContext context) {
    var db = context.getDatabaseSession();
    var alias = matchFilter.getAlias();
    var filter = matchFilter.getFilter();
    if (alias != null) {
      if (filter != null && filter.baseExpression != null) {
        var previousFilter = aliasFilters.get(alias);
        if (previousFilter == null) {
          previousFilter = new SQLWhereClause(-1);
          previousFilter.baseExpression = new SQLAndBlock(-1);
          aliasFilters.put(alias, previousFilter);
        }
        var filterBlock = (SQLAndBlock) previousFilter.baseExpression;
        if (filter != null && filter.baseExpression != null) {
          filterBlock.subBlocks.add(filter.baseExpression);
        }
      }

      var clazz = matchFilter.getClassName(context);
      if (clazz != null) {
        var previousClass = aliasClasses.get(alias);
        if (previousClass == null) {
          aliasClasses.put(alias, clazz);
        } else {
          var lower = getLowerSubclass(db, clazz, previousClass);
          if (lower == null) {
            throw new CommandExecutionException(
                "classes defined for alias "
                    + alias
                    + " ("
                    + clazz
                    + ", "
                    + previousClass
                    + ") are not in the same hierarchy");
          }
          aliasClasses.put(alias, lower);
        }
      }
    }
  }

  private String getLowerSubclass(DatabaseSessionInternal session, String className1,
      String className2) {
    Schema schema = session.getMetadata().getSchema();
    var class1 = schema.getClass(className1);
    var class2 = schema.getClass(className2);
    if (class1 == null) {
      throw new CommandExecutionException(session,
          "Class " + className1 + " not found in the schema");
    }
    if (class2 == null) {
      throw new CommandExecutionException(session,
          "Class " + className2 + " not found in the schema");
    }
    if (class1.isSubClassOf(session, class2)) {
      return class1.getName(session);
    }
    if (class2.isSubClassOf(session, class1)) {
      return class2.getName(session);
    }
    return null;
  }

  @Override
  public boolean isIdempotent() {
    return true;
  }

  public void toString(Map<Object, Object> params, StringBuilder builder) {
    builder.append(KEYWORD_MATCH);
    builder.append(" ");
    var first = true;
    for (var expr : this.matchExpressions) {
      if (!first) {
        builder.append(", ");
      }
      expr.toString(params, builder);
      first = false;
    }
    builder.append(" RETURN ");
    if (returnDistinct) {
      builder.append("DISTINCT ");
    }
    first = true;
    var i = 0;
    for (var expr : this.returnItems) {
      if (!first) {
        builder.append(", ");
      }
      expr.toString(params, builder);
      if (returnNestedProjections != null
          && i < returnNestedProjections.size()
          && returnNestedProjections.get(i) != null) {
        returnNestedProjections.get(i).toString(params, builder);
      }
      if (returnAliases != null && i < returnAliases.size() && returnAliases.get(i) != null) {
        builder.append(" AS ");
        returnAliases.get(i).toString(params, builder);
      }
      i++;
      first = false;
    }
    if (groupBy != null) {
      builder.append(" ");
      groupBy.toString(params, builder);
    }
    if (orderBy != null) {
      builder.append(" ");
      orderBy.toString(params, builder);
    }
    if (unwind != null) {
      builder.append(" ");
      unwind.toString(params, builder);
    }
    if (skip != null) {
      builder.append(" ");
      skip.toString(params, builder);
    }
    if (limit != null) {
      builder.append(" ");
      limit.toString(params, builder);
    }
  }

  public void toGenericStatement(StringBuilder builder) {
    builder.append(KEYWORD_MATCH);
    builder.append(" ");
    var first = true;
    for (var expr : this.matchExpressions) {
      if (!first) {
        builder.append(", ");
      }
      expr.toGenericStatement(builder);
      first = false;
    }
    builder.append(" RETURN ");
    if (returnDistinct) {
      builder.append("DISTINCT ");
    }
    first = true;
    var i = 0;
    for (var expr : this.returnItems) {
      if (!first) {
        builder.append(", ");
      }
      expr.toGenericStatement(builder);
      if (returnNestedProjections != null
          && i < returnNestedProjections.size()
          && returnNestedProjections.get(i) != null) {
        returnNestedProjections.get(i).toGenericStatement(builder);
      }
      if (returnAliases != null && i < returnAliases.size() && returnAliases.get(i) != null) {
        builder.append(" AS ");
        returnAliases.get(i).toGenericStatement(builder);
      }
      i++;
      first = false;
    }
    if (groupBy != null) {
      builder.append(" ");
      groupBy.toGenericStatement(builder);
    }
    if (orderBy != null) {
      builder.append(" ");
      orderBy.toGenericStatement(builder);
    }
    if (unwind != null) {
      builder.append(" ");
      unwind.toGenericStatement(builder);
    }
    if (skip != null) {
      builder.append(" ");
      skip.toGenericStatement(builder);
    }
    if (limit != null) {
      builder.append(" ");
      limit.toGenericStatement(builder);
    }
  }

  @Override
  public Iterator<Identifiable> iterator(DatabaseSessionInternal session,
      Map<Object, Object> iArgs) {
    if (context == null) {
      var context = new BasicCommandContext();
      context.setDatabaseSession(session);

      this.context = context;
    }

    var result = execute(session, iArgs);
    return result.stream().map(x -> (Identifiable) x.getRecordId()).iterator();
  }

  @Override
  public SQLMatchStatement copy() {
    var result = new SQLMatchStatement(-1);
    result.matchExpressions =
        matchExpressions == null
            ? null
            : matchExpressions.stream()
                .map(x -> x == null ? null : x.copy())
                .collect(Collectors.toList());
    result.notMatchExpressions =
        notMatchExpressions == null
            ? null
            : notMatchExpressions.stream()
                .map(x -> x == null ? null : x.copy())
                .collect(Collectors.toList());
    result.returnItems =
        returnItems == null
            ? null
            : returnItems.stream()
                .map(x -> x == null ? null : x.copy())
                .collect(Collectors.toList());
    result.returnAliases =
        returnAliases == null
            ? null
            : returnAliases.stream()
                .map(x -> x == null ? null : x.copy())
                .collect(Collectors.toList());
    result.returnNestedProjections =
        returnNestedProjections == null
            ? null
            : returnNestedProjections.stream()
                .map(x -> x == null ? null : x.copy())
                .collect(Collectors.toList());
    result.groupBy = groupBy == null ? null : groupBy.copy();
    result.orderBy = orderBy == null ? null : orderBy.copy();
    result.unwind = unwind == null ? null : unwind.copy();
    result.skip = skip == null ? null : skip.copy();
    result.limit = limit == null ? null : limit.copy();
    result.returnDistinct = this.returnDistinct;
    result.buildPatterns();
    return result;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }

    var that = (SQLMatchStatement) o;

    if (!Objects.equals(matchExpressions, that.matchExpressions)) {
      return false;
    }
    if (!Objects.equals(notMatchExpressions, that.notMatchExpressions)) {
      return false;
    }
    if (!Objects.equals(returnItems, that.returnItems)) {
      return false;
    }
    if (!Objects.equals(returnAliases, that.returnAliases)) {
      return false;
    }
    if (!Objects.equals(returnNestedProjections, that.returnNestedProjections)) {
      return false;
    }
    if (!Objects.equals(groupBy, that.groupBy)) {
      return false;
    }
    if (!Objects.equals(orderBy, that.orderBy)) {
      return false;
    }
    if (!Objects.equals(unwind, that.unwind)) {
      return false;
    }
    if (!Objects.equals(skip, that.skip)) {
      return false;
    }
    if (!Objects.equals(limit, that.limit)) {
      return false;
    }

    return returnDistinct == that.returnDistinct;
  }

  @Override
  public int hashCode() {
    var result = matchExpressions != null ? matchExpressions.hashCode() : 0;
    result = 31 * result + (notMatchExpressions != null ? notMatchExpressions.hashCode() : 0);
    result = 31 * result + (returnItems != null ? returnItems.hashCode() : 0);
    result = 31 * result + (returnAliases != null ? returnAliases.hashCode() : 0);
    result =
        31 * result + (returnNestedProjections != null ? returnNestedProjections.hashCode() : 0);
    result = 31 * result + (groupBy != null ? groupBy.hashCode() : 0);
    result = 31 * result + (orderBy != null ? orderBy.hashCode() : 0);
    result = 31 * result + (unwind != null ? unwind.hashCode() : 0);
    result = 31 * result + (skip != null ? skip.hashCode() : 0);
    result = 31 * result + (limit != null ? limit.hashCode() : 0);
    return result;
  }

  public SQLLimit getLimit() {
    return limit;
  }

  public void setLimit(SQLLimit limit) {
    this.limit = limit;
  }

  public List<SQLIdentifier> getReturnAliases() {
    return returnAliases;
  }

  public void setReturnAliases(List<SQLIdentifier> returnAliases) {
    this.returnAliases = returnAliases;
  }

  public List<SQLExpression> getReturnItems() {
    return returnItems;
  }

  public void setReturnItems(List<SQLExpression> returnItems) {
    this.returnItems = returnItems;
  }

  public List<SQLMatchExpression> getMatchExpressions() {
    return matchExpressions;
  }

  public void setMatchExpressions(List<SQLMatchExpression> matchExpressions) {
    this.matchExpressions = matchExpressions;
  }

  public List<SQLMatchExpression> getNotMatchExpressions() {
    return notMatchExpressions;
  }

  public void setNotMatchExpressions(List<SQLMatchExpression> notMatchExpressions) {
    this.notMatchExpressions = notMatchExpressions;
  }

  public boolean isReturnDistinct() {
    return returnDistinct;
  }

  public void setReturnDistinct(boolean returnDistinct) {
    this.returnDistinct = returnDistinct;
  }

  public SQLOrderBy getOrderBy() {
    return orderBy;
  }

  public void setOrderBy(SQLOrderBy orderBy) {
    this.orderBy = orderBy;
  }

  public SQLGroupBy getGroupBy() {
    return groupBy;
  }

  public void setGroupBy(SQLGroupBy groupBy) {
    this.groupBy = groupBy;
  }

  public SQLUnwind getUnwind() {
    return unwind;
  }

  public void setUnwind(SQLUnwind unwind) {
    this.unwind = unwind;
  }

  public SQLSkip getSkip() {
    return skip;
  }

  public void setSkip(SQLSkip skip) {
    this.skip = skip;
  }

  @Override
  public boolean refersToParent() {
    // TODO check this!
    return false;
  }
}
/* JavaCC - OriginalChecksum=6ff0afbe9d31f08b72159fcf24070c9f (do not edit this line) */
